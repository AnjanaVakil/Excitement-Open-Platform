/**
 * 
 */
package eu.excitementproject.eop.distsim.builders.cooccurrence;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;


import eu.excitementproject.eop.distsim.domains.relation.PredicateArgumentSlots;
import eu.excitementproject.eop.distsim.items.ArgumentFeature;
import eu.excitementproject.eop.distsim.items.Cooccurrence;
import eu.excitementproject.eop.distsim.items.DefaultCooccurrence;
import eu.excitementproject.eop.distsim.items.DefaultRelation;
import eu.excitementproject.eop.distsim.items.Element;
import eu.excitementproject.eop.distsim.items.Feature;
import eu.excitementproject.eop.distsim.items.IDBasedCooccurrence;
import eu.excitementproject.eop.distsim.items.LemmaPosTextUnit;
import eu.excitementproject.eop.distsim.items.LexicalUnit;
import eu.excitementproject.eop.distsim.items.PredicateElement;
import eu.excitementproject.eop.distsim.items.Relation;
import eu.excitementproject.eop.distsim.items.TextUnit;
import eu.excitementproject.eop.distsim.items.UndefinedKeyException;
import eu.excitementproject.eop.distsim.util.Configuration;
import eu.excitementproject.eop.distsim.util.Filter;
import eu.excitementproject.eop.distsim.util.Pair;
import eu.excitementproject.eop.distsim.util.Serialization;
import eu.excitementproject.eop.distsim.util.SerializationException;
import eu.excitementproject.eop.distsim.util.SetBasedPOSFilter;

import ac.biu.nlp.nlp.general.configuration.ConfigurationException;
import ac.biu.nlp.nlp.general.configuration.ConfigurationParams;
import ac.biu.nlp.nlp.instruments.parse.DependencyPathsFromTreeBinary;
import ac.biu.nlp.nlp.instruments.parse.DependencyPathsFromTreeUnaryBinc;
import ac.biu.nlp.nlp.instruments.parse.representation.basic.Info;
import ac.biu.nlp.nlp.instruments.parse.tree.AbstractNodeUtils;
import ac.biu.nlp.nlp.instruments.parse.tree.dependency.basic.BasicNode;
import ac.biu.nlp.nlp.instruments.parse.tree.dependency.basic.BasicNodeConstructor;
import ac.biu.nlp.nlp.representation.CanonicalPosTag;
import ac.biu.nlp.nlp.representation.PartOfSpeech;

/**
 * @author Meni Adler
 * @since 04/09/2012
 *
 */
public class NodeBasedWordCooccurrenceExtraction extends WordCooccurrenceExtraction<BasicNode> {

	public NodeBasedWordCooccurrenceExtraction() {
		this.extractor =  new DependencyPathsFromTreeBinary<Info, BasicNode>(new BasicNodeConstructor(), true, true);
		this.posFilter = new SetBasedPOSFilter();
	}

	public NodeBasedWordCooccurrenceExtraction(ConfigurationParams confParams) throws ConfigurationException {
		this.extractor =  new DependencyPathsFromTreeBinary<Info, BasicNode>(new BasicNodeConstructor(), true, true);
		this.posFilter = new SetBasedPOSFilter(confParams);
	}

	public NodeBasedWordCooccurrenceExtraction(CanonicalPosTag... relevantPOSs) {
		this.extractor =  new DependencyPathsFromTreeBinary<Info, BasicNode>(new BasicNodeConstructor(), true, true);
		this.posFilter = new SetBasedPOSFilter(relevantPOSs);
	}
	
	/* (non-Javadoc)
	 * @see org.excitement.distsim.builders.cooccurrence.CooccurrenceExtraction#extractCooccurrences(java.lang.Object)
	 */
	@Override
	public Pair<? extends List<? extends TextUnit>, ? extends List<? extends Cooccurrence<String>>> extractCooccurrences(BasicNode root) throws CooccurrenceExtractionException {
		List<LemmaPosTextUnit> textUnints = new LinkedList<LemmaPosTextUnit>();
		List<DefaultCooccurrence<String>> coOccurrences = new LinkedList<DefaultCooccurrence<String>>();
		try {
			//@todo: check opposite relation parent->child
			for (BasicNode node : AbstractNodeUtils.treeToSet(root)) {
				if (relevantNode(node) && relevantNode(node.getAntecedent())) {
					LemmaPosTextUnit child = new LemmaPosTextUnit(node.getInfo().getNodeInfo().getWordLemma(),node.getInfo().getNodeInfo().getSyntacticInfo().getPartOfSpeech().getCanonicalPosTag());
					LemmaPosTextUnit parent = new LemmaPosTextUnit(node.getAntecedent().getInfo().getNodeInfo().getWordLemma(),node.getInfo().getNodeInfo().getSyntacticInfo().getPartOfSpeech().getCanonicalPosTag());
					Relation<String> rel = new DefaultRelation<String>(node.getInfo().getEdgeInfo().getDependencyRelation().getStringRepresentation());
					textUnints.add(parent);
					textUnints.add(child);
					coOccurrences.add(new DefaultCooccurrence<String>(child, parent,rel));
				}
			}
		} catch (Exception e) {			
			throw new CooccurrenceExtractionException(e);
		}
		return new Pair<List<LemmaPosTextUnit>,List<DefaultCooccurrence<String>>>(textUnints,coOccurrences);
	}

	protected boolean relevantNode(BasicNode node) {
		return posFilter.isRelevant(node.getInfo().getNodeInfo().getSyntacticInfo().getPartOfSpeech().getCanonicalPosTag());
	}

	/* (non-Javadoc)
	 * @see org.excitement.distsim.builders.cooccurrence.CooccurrenceExtraction#string2data(java.lang.String)
	 */
	@Override
	public Pair<BasicNode,Long> extractDataCount(String str) throws SerializationException {
		return new Pair<BasicNode,Long>((BasicNode)Serialization.deserialize(str), 1L);
	}

	DependencyPathsFromTreeBinary<Info, BasicNode> extractor;
	Filter<CanonicalPosTag> posFilter;
}
